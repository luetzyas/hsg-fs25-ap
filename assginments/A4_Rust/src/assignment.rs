use std::marker::PhantomData;

// ---------------------------------
// 1. Natural Numbers
// ---------------------------------
/*
    1: Natural Numbers
    Implement the nats function, which returns the stream of natural numbers, 
    i.e. [0, 1, 2, 3, ...].
*/
// stream trait
pub trait Stream<A> {
    fn next(&mut self) -> Option<A>;
}
// nats struct
pub struct Nats {
    current: usize,
}
// nats stream
impl Stream<usize> for Nats {
    fn next(&mut self) -> Option<usize> {
        let value = self.current;
        self.current = self.current + 1;
        Some(value)
    }
}
/* re-write nats using Generate in Task 3
pub fn nats() -> impl Stream<usize> {
    print!("=== Task 1: nats() called\n");
    Nats { current: 0 }
}
*/
//
// ---------------------------------
// 2. Stream Combinators
// ---------------------------------
/*
    Task 2: Take
    Implement the take function, which takes the first n elements of a stream and then 
    exhausts it. Use it to implement the stream of the first three natural 
    numbers, i.e., [0, 1, 2].
*/
// take struct
pub struct Take<A, S: Stream<A>> {
    stream: S,
    remaining: usize,
    _marker: PhantomData<A>,
}
// take stream
impl<A, S: Stream<A>> Stream<A> for Take<A, S> {
    fn next(&mut self) -> Option<A> {
        if self.remaining == 0 {
            None
        } else {
            self.remaining = self.remaining - 1;
            self.stream.next()
        }
    }
}
// take function
pub fn take<A, S: Stream<A>>(stream: S, n: usize) -> impl Stream<A> {
    print!("$ take() called\n");
    Take {
        stream,
        remaining: n,
        _marker: PhantomData,
    }
}
/*
    Task 3: Generate
    Implement the generate function, which returns a stream whose elements 
    are generated by repeatedly applying a generator function to the last 
    element produced, starting from an initial element. Use it to re-implement 
    the stream of natural numbers.
*/
// generate struct
pub struct Generate<A, F>
where
    F: Fn(&A) -> A,
{
    current: Option<A>,
    generator: F,
    _marker: PhantomData<A>,
}
// generate stream
impl<A, F> Stream<A> for Generate<A, F>
where
    F: Fn(&A) -> A,
{
    fn next(&mut self) -> Option<A> {
        match self.current.take() {
            Some(value) => {
                let next_value = (self.generator)(&value);
                self.current = Some(next_value);
                Some(value)
            }
            None => None,
        }
    }
}
// generate function
pub fn generate<A, F>(start: A, generator: F) -> impl Stream<A>
where
    F: Fn(&A) -> A,
{
    print!("$ generate() called\n");
    Generate {
        current: Some(start),
        generator,
        _marker: PhantomData,
    }
}
// re-implement nats using generate
pub fn nats() -> impl Stream<usize> {
    generate(0usize, |x| x + 1)
}

/*
    Task 4: Map
    Implement the map function, which returns a stream whose elements are 
    generated by applying a transformation function to the elements of another 
    stream. Use it to implement the stream of squares, i.e., [0, 1, 4, 9, ...].
*/
//map struct
pub struct Map<A, B, S, F>
where
    S: Stream<A>,
    F: Fn(A) -> B,
{
    stream: S,
    f: F,
    _marker: PhantomData<(A, B)>,
}
// map stream 
impl<A, B, S, F> Stream<B> for Map<A, B, S, F>
where
    S: Stream<A>,
    F: Fn(A) -> B,
{
    fn next(&mut self) -> Option<B> {
        match self.stream.next() {
            Some(value) => Some((self.f)(value)),
            None => None,
        }
    }
}
// map function
pub fn map<A, B, S, F>(stream: S, f: F) -> impl Stream<B>
where
    S: Stream<A>,
    F: Fn(A) -> B,
{
    Map {
        stream,
        f,
        _marker: PhantomData,
    }
}
// use it to implement the stream of squares
pub fn squares() -> impl Stream<usize> {
    print!("$ squares() called\n");
    map(nats(), |x| x * x)
}
/*
    Task 5: Filter
    Implement the filter function, which returns a stream whose elements are 
    generated by discarding the elements of another stream that do no satisfy 
    a given predicate. Use it to implement the stream of even numbers, 
    i.e., [0, 2, 4, 6, ...].
*/
// filter struct
pub struct Filter<A, S, P>
where
    S: Stream<A>,
    P: Fn(&A) -> bool,
{
    stream: S,
    predicate: P,
    _marker: PhantomData<A>,
}
// filter stream
impl<A, S, P> Stream<A> for Filter<A, S, P>
where
    S: Stream<A>,
    P: Fn(&A) -> bool,
{
    fn next(&mut self) -> Option<A> {
        loop {
            match self.stream.next() {
                Some(value) => {
                    if (self.predicate)(&value) {
                        return Some(value);
                    }
                    // sonst: Wert verwerfen und weiter
                }
                None => return None,
            }
        }
    }
}
// filter function
pub fn filter<A, S, P>(stream: S, predicate: P) -> impl Stream<A>
where
    S: Stream<A>,
    P: Fn(&A) -> bool,
{
    print!("$ filter() called\n");
    Filter {
        stream,
        predicate,
        _marker: PhantomData,
    }
}
// use it to implement the stream of even numbers
pub fn evens() -> impl Stream<usize> {
    filter(nats(), |x| x % 2 == 0)
}
/*
    Task 6: Aggregate
    Implement the aggregate function, which returns a stream of aggregate 
    results. Each result is obtained by composing the next element of another 
    stream with the previous result, starting from an initial result. 
    Use it to implement the stream of factorials, i.e., [1, 1, 2, 6, 24, ...].
*/
// aggregate struct
pub struct Aggregate<A, B, S, F>
where
    S: Stream<A>,
    F: Fn(&B, A) -> B,
{
    stream: S,
    acc: Option<B>,
    f: F,
    _marker: PhantomData<A>,
}
// aggregate stream
impl<A, B, S, F> Stream<B> for Aggregate<A, B, S, F>
where
    S: Stream<A>,
    F: Fn(&B, A) -> B,
{
    fn next(&mut self) -> Option<B> {
        match self.stream.next() {
            Some(value) => {
                let old = self.acc.take().unwrap();
                let new = (self.f)(&old, value);
                self.acc = Some(new);
                Some(old)
            }
            None => None,
        }
    }
}

// aggregate function
pub fn aggregate<A, B, S, F>(
    stream: S,
    initial: B,
    f: F,
) -> impl Stream<B>
where
    S: Stream<A>,
    F: Fn(&B, A) -> B,
{
    Aggregate {
        stream,
        acc: Some(initial),
        f,
        _marker: PhantomData,
    }
}
// use it to implement the stream of factorials
pub fn factorials() -> impl Stream<usize> {
    print!("$ factorials() called\n");
    let s = skip(nats(), 1);
    aggregate(s, 1usize, |acc, x| acc * x)
}
//
// ---------------------------------
// 3. Fluent Style
// ---------------------------------
/*
    Task 7: Fluent Style
    Define a trait StreamOps that extends Stream with methods for skip, 
    vec, map, filter, and aggregate, so that they can be chained in fluent 
    style. Provide an implementation of this trait for ALL Streams.
*/
// StreamOps trait
pub trait StreamOps<A>: Stream<A> + Sized {
    fn take(self, n: usize) -> impl Stream<A>;

    fn map<B, F>(self, f: F) -> impl Stream<B>
    where
        F: Fn(A) -> B;

    fn filter<F>(self, f: F) -> impl Stream<A>
    where
        F: Fn(&A) -> bool;

    fn aggregate<B, F>(self, init: B, f: F) -> impl Stream<B>
    where
        F: Fn(&B, A) -> B;

    fn vec(self) -> Vec<A>;
}
// StreamOps implementation for all Streams
impl<A, S> StreamOps<A> for S
where
    S: Stream<A>,
{
    fn take(self, n: usize) -> impl Stream<A> {
        take(self, n)
    }

    fn vec(mut self) -> Vec<A> {
        let mut out = Vec::new();
        while let Some(v) = self.next() {
            out.push(v);
        }
        out
    }

    fn map<B, F>(self, f: F) -> impl Stream<B>
    where
        F: Fn(A) -> B,
    {
        map(self, f)
    }

    fn filter<F>(self, f: F) -> impl Stream<A>
    where
        F: Fn(&A) -> bool,
    {
        filter(self, f)
    }

    fn aggregate<B, F>(self, init: B, f: F) -> impl Stream<B>
    where
        F: Fn(&B, A) -> B,
    {
        aggregate(self, init, f)
    }
}

// use fluent style
pub fn fluent_style_example() -> Vec<usize> {
    print!("$ Fluent Style Example called\n");
    nats()
        .filter(|x| x % 2 == 0)
        .map(|x| x * x)
        .take(5)
        .vec()
}
//
// ---------------------------------
// 4. Hoking to the Standard Library
// ---------------------------------
/*
    Task 8: Streamable... once
    Define the trait StreamableOnce. Implementors of this trait must 
    provide a method stream_once, which consumes the implementor to 
    return a stream of its elements. Provide an implementation of this 
    trait for Vec. Use it to create the stream of magical 
    numbers [22, 13, 42].
*/
// StreamableOnce trait
pub trait StreamableOnce<A> {
    fn stream_once(self) -> impl Stream<A>;
}
// StreamableOnce struct
pub struct VecStream<A> {
    vec: Vec<A>,
    index: usize,
}
// implement Stream for VecStream
impl<A> Stream<A> for VecStream<A> {
    fn next(&mut self) -> Option<A> {
        if self.index < self.vec.len() {
            let value = std::mem::replace(&mut self.vec[self.index], unsafe {
                std::mem::MaybeUninit::zeroed().assume_init()
            });
            self.index += 1;
            Some(value)
        } else {
            None
        }
    }
}
// StreamableOnce implementation for Vec
impl<A> StreamableOnce<A> for Vec<A> {
    fn stream_once(self) -> impl Stream<A> {
        VecStream {
            vec: self,
            index: 0,
        }
    }
}
// use it to create the stream of magical numbers
pub fn magical_numbers() -> Vec<usize> {
    print!("$ Magical Numbers Example called\n");
    vec![22, 13, 42]
        .stream_once()
        .vec()
}
/*
    Task 9: Ownership and Borrowing
    What is a limitation with StreamableOnce? Show an example of useful 
    application where compilation fails because of ownership. 
    Show another example of useful application where compilation fails 
    because of borrowing.
*/
/* 
Example 1: StreamableOnce ownership limitation
let v = vec![1, 2, 3];
let s1 = v.stream_once(); // takes vec by value (ownership moved)
let s2 = v.stream_once(); // fail -> ownership already moved to s1

Example 2: Borrowing limitation
let v = vec![1, 2, 3];
let mut s = v.stream_once(); // takes vec by value (ownership moved)
let x = v.len();             // fail -> cannot borrow `v` because it has been moved
*/
//
// ---------------------------------
// 5. Stramable... not only once!
// ---------------------------------
/*
    Task 10: Streamable ... not only once!
    Define the trait Streamable as described above. Provide an 
    implementation of this trait for Vec. Show how this implementation 
    overcomes the limitations in the examples of the previous task.
    - trait Streamable<A> { fn stream(&self) -> impl Stream<A> }
    - struct RefVecStream<’a, A> { source: &’a Vec<A>, /* other fields */ }
    - trait Streamable<’a, A> { fn stream(&’a self) -> impl Stream<A> + ’a; }
*/
// Streamable trait
pub trait Streamable <'a,A> {
    fn stream(&'a self) -> impl Stream<A> + 'a; 
}
// RefVecStream struct
pub struct RefVecStream<'a, A> {
    vec: &'a Vec<A>,
    index: usize,
}
// implement Stream for RefVecStream
impl<'a, A> Stream<&'a A> for RefVecStream<'a, A> {
    fn next(&mut self) -> Option<&'a A> {
        if self.index < self.vec.len() {
            let value = &self.vec[self.index];
            self.index += 1;
            Some(value)
        } else {
            None
        }
    }
}
// Streamable implementation for Vec
impl<'a, A> Streamable<'a, &'a A> for Vec<A> {
    fn stream(&'a self) -> impl Stream<&'a A> + 'a {
        RefVecStream {
            vec: self,
            index: 0,
        }
    }
}
// Example usage of Streamable to overcome limitations
pub fn example_streamable() {
    let v = vec![1, 2, 3];  
    let mut s1 = v.stream(); // borrows vec
    let mut s2 = v.stream(); // borrows vec again, no ownership moved
    println!("s1 next: {:?}", s1.next()); // Some(&1)
    println!("s2 next: {:?}", s2.next()); // Some(&1)
}

// ---------------------------------
// run tasks
// ---------------------------------
/// Skip the first n elements of a [Stream]
pub fn skip<A, S: Stream<A>>(mut source: S, n: usize) -> S {
    for _ in 0..n {
        source.next();
    }
    source
}
fn print_stream<S: Stream<usize>>(mut stream: S, n: usize) {
    for i in 0..n {
        println!("{}: {:?}", i, stream.next());
    }
}
fn print_title(title: &str) {
    let total_width: usize = 50;
    let prefix = "=== ";
    let used = prefix.len() + title.len() + 1; // +1 fuer Leerzeichen vor den =
    let eq_count = total_width.saturating_sub(used);
    let suffix = "=".repeat(eq_count);
    // Ausgabe
    println!("\n{}{} {}", prefix, title, suffix);
}
fn main() {
    // Task 1: Natural Numbers
    print_title("Task 1: Natural Numbers");
    let s1 = nats();
    print_stream(s1, 1);
    /*  
        === Task 1: Natural Numbers ======================
        $ generate() called
        0: Some(0)
    */
    //----------------------------------------------------
    // Task 2: Take
    print_title("Task 2: Take");
    let s2 = nats().take(3);
    print_stream(s2, 2);
    /*
        terminal oputput:
        === Task 2: Take =================================
        $ generate() called
        $ take() called
        0: Some(0)
        1: Some(1)
    */
    //----------------------------------------------------
    // Task 3: Generate
    print_title("Task 3: Generate");
    let s3 = generate(0, |x| x + 1);
    print_stream(s3, 3);
    /*
        terminal oputput:
        === Task 3: Generate =============================
        $ generate() called
        0: Some(0)
        1: Some(1)
        2: Some(2)
    */
    //----------------------------------------------------    
    // Task 4: Map
    print_title("Task 4: Map");
    let s4 = squares();
    print_stream(s4, 4);
    /*
        terminal oputput:
        === Task 4: Map ==================================
        $ squares() called
        $ generate() called
        0: Some(0)
        1: Some(1)
        2: Some(4)
        3: Some(9)
    */
    //----------------------------------------------------
    // Task 5: Filter
    print_title("Task 5: Filter");
    let s5 = evens();
    print_stream(s5, 5);
    /*
        terminal oputput:
        === Task 5: Filter ===============================
        $ generate() called
        $ filter() called
        0: Some(0)
        1: Some(2)
        2: Some(4)
        3: Some(6)
        4: Some(8)
    */
    //----------------------------------------------------
    // Task 6: Aggregate
    print_title("Task 6: Aggregate");
    let s6 = factorials();
    print_stream(s6, 6);
    /* 
        terminal oputput:
        === Task 6: Aggregate ============================
        $ factorials() called
        $ generate() called
        0: Some(1)
        1: Some(1)
        2: Some(2)
        3: Some(6)
        4: Some(24)
        5: Some(120)
    */
    //----------------------------------------------------
    // Task 7: Fluent Style
    print_title("Task 7: Fluent Style");
    let res7 = fluent_style_example();
    println!("Fluent Style Result: {:?}", res7);
    /* 
        terminal oputput:
        === Task 7: Fluent Style =========================
        $ Fluent Style Example called
        $ generate() called
        $ filter() called
        $ take() called
        Fluent Style Result: [0, 4, 16, 36, 64]
    */

    //----------------------------------------------------
    // Task 8: Streamable... once
    print_title("Task 8: Streamable... once");
    let res8 = magical_numbers();
    println!("Magical Numbers: {:?}", res8);
    /* 
        terminal oputput:
        === Task 8: Streamable... once ===================
        $ Magical Numbers Example called
        Magical Numbers: [22, 13, 42]
    */
    //----------------------------------------------------
    // Task 9: Ownership and Borrowing
    print_title("Task 9: Ownership and Borrowing");
    println!("See code comments for examples of limitations.");
    //----------------------------------------------------
    // Task 10: Streamable ... not only once!
    print_title("Task 10: Streamable ... not only once!");
    example_streamable();
    /* 
        terminal oputput:
        === Task 10: Streamable ... not only once! =======
        s1 next: Some(1)
        s2 next: Some(1)
    */
}